extendint.h is for C/C++ users, compiler ver c99 and above is required, please follow the instructions in the file  
  
extendint++.h is for C++ users only, with most operators reconstructed, a^b represents pow(a,b), other operators are the same as normal datatypes  
  
the two files above are experimental high accuracy calculation functions for integers, may still have some unexpeceted bugs left  

DateType is a pre-defined datatype which presents a date in the form of yyyy-mm-dd, I set the maximum date to year 9999, it has a function to turn strings to Date type, and basic comparisons have been reconstructed

Chris.h is a header for C++ users, featuring rb-tree structure which adjusts memory usage according to current node count, meanwhile being twice as fast as stl set when inserting and hundred times faster than stl set when freeing the memory

note:  
1. extendint————  
&ensp;&ensp;&ensp;fft or ntt is NOT used in extendint algorithm, which means it might take huge amount of time calculationg big numbers, this might be optimized some day when I actually learn them  
&ensp;&ensp;&ensp;due to my ignorance, bit opertations can yet be realized, this might NOT get optimized since i dont know how  
&ensp;&ensp;&ensp;in my ide, errors pop up when I set the 'maxlength' variable too big (about 5e4), I guess there's some stack overflow issue, so be really carefull when modifying this  
2. _Chris::rbtree and _Alter::rbtree————  
&ensp;&ensp;&ensp;Acting as a multiset like class, both rbtree classes provides some basic multiset operations, yet my rbtree optimizes memory operations and speeding it up compared to stl sets and multisets.
&ensp;&ensp;&ensp;The _Chris version is an old version which might be buggy, but it did passed a few tests and showed reasonably good performance. The _Alter version is a newer version, in which memory operations are further optimized by deriving rvalue operations from lvalue operations. The _Alter version also uses a new resize scheme which make removing keys much faster.
&ensp;&ensp;&ensp;With all the performance optimized, it can be a bit tricky to use this class. First, in order to instantiate an _Alter::rbtree class with an inter class T, the class T (whatever it is) must allow default initialize like T(). Second, I set the default value of 'do_alloc' to 0 so that when classes with heap memory resources are constructed recursively, there won't be an useless initialize, if you wang to initialize a usable rbtree class, initialize it like `rbtree<T>newtree(1)` to tell it to alloc memory for further use, or you can use `newtree.reinit(1)` to realloc memory for newtree, this method always deletes the former alloced block of memory (if any) before allocs for a new block.
&ensp;&ensp;&ensp;It's possible to pass in a compare method into the rbtree class, if not, a default compare function will be used. Passing a custom compare method may be helpful to improve performance, in my rbtree funtion, a compare method must follow some rules————it must be a binary operation, with both the parameters be the class used to instantiate rbtree in the form of `const T& thiskey`; it must return 0 when the former key is 'less than' the latter, 1 if former>latter and 2 if former==latter; it must be passed into the rbtree while instantiating and never get changed. If you don't want to use customed compare method, then the class used to instantiate rbtree must have operator> and operator==.
&ensp;&ensp;&ensp;There is an Iterator type inside _Alter::rbtree, it's a read-only ringed iterator, using getkey() to return the quote value, and copykey() to return a copy of the quote value, the copy method depends on how the inter class performs T(T&key){}. Being a ringed iterator, there's an 'doom node' which indicates 'end' state, in which getkey() returns a default value of inter class (which is meaningless). Among all the operations overloaded in the iterator, NONE of them gives ensurance that their own operations WILL NOT cause the tail forwarding to the head and starts a new loop, but  `forward() ` and `backward()` method returns 1 if the destination is not 'end', and 0 if it is, so you can either use `iter==tree.end()` or `iter.forward()==0` to tell whether this loop has ended, but you can't do the same thing using other operations like ++ or += since they need to return the iterator itself instead of a bool.  
